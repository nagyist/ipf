/**
 * II.java
 * <p>
 * File generated from the datatypes::II uml Class
 * Generated by IHE - europe, gazelle team
 */
package net.ihe.gazelle.hl7v3.datatypes;

// End of user code
import java.io.Serial;
import java.util.List;
import java.util.Objects;

import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Marshaller;
import jakarta.xml.bind.annotation.XmlAccessType;
import jakarta.xml.bind.annotation.XmlAccessorType;
import jakarta.xml.bind.annotation.XmlAttribute;
import jakarta.xml.bind.annotation.XmlRootElement;
import jakarta.xml.bind.annotation.XmlTransient;
import jakarta.xml.bind.annotation.XmlType;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import net.ihe.gazelle.gen.common.ConstraintValidatorModule;

import org.w3c.dom.Document;
import org.w3c.dom.Node;


/**
 * Description of the class II.
 *
 * 
 */

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "II", propOrder = {
	"assigningAuthorityName",
	"displayable",
	"extension",
	"root"
})
@XmlRootElement(name = "II")
public class II extends net.ihe.gazelle.hl7v3.datatypes.ANY implements java.io.Serializable {
	
	/**
	 * 
	 */
	@Serial
    private static final long serialVersionUID = 1L;

	
	/**
	 * 
	                     A human readable name or mnemonic for the assigning
	                     authority. This name may be provided solely for the
	                     convenience of unaided humans interpreting an  value
	                     and can have no computational meaning. Note: no
	                     automated processing must depend on the assigning
	                     authority name to be present in any form.
	                  .
	 */
	@XmlAttribute(name = "assigningAuthorityName")
	public String assigningAuthorityName;
	/**
	 * 
	                     Specifies if the identifier is intended for human
	                     display and data entry (displayable = true) as
	                     opposed to pure machine interoperation (displayable
	                     = false).
	                  .
	 */
	@XmlAttribute(name = "displayable")
	public Boolean displayable;
	/**
	 * 
	                     A character string as a unique identifier within the
	                     scope of the identifier root.
	                  .
	 */
	@XmlAttribute(name = "extension")
	public String extension;
	/**
	 * 
	                     A unique identifier that guarantees the global uniqueness
	                     of the instance identifier. The root alone may be the
	                     entire instance identifier.
	                  .
	 */
	@XmlAttribute(name = "root")
	public String root;
	/**
	 * An attribute containing marshalled element node
	 */
	@XmlTransient
	private org.w3c.dom.Node _xmlNodePresentation;
	
	
	public II(){
		
	}
	
	public II(String inRoot, String inExtension){
		super();
		this.root = inRoot;
		this.extension = inExtension;
	}

	public II(String inRoot, String inExtension, String assigningAuthorityName){
		super();
		this.root = inRoot;
		this.extension = inExtension;
		this.assigningAuthorityName = assigningAuthorityName;
	}
	
	/**
	 * Return assigningAuthorityName.
	 * @return assigningAuthorityName : 
	                     A human readable name or mnemonic for the assigning
	                     authority. This name may be provided solely for the
	                     convenience of unaided humans interpreting an  value
	                     and can have no computational meaning. Note: no
	                     automated processing must depend on the assigning
	                     authority name to be present in any form.
	 */
	public String getAssigningAuthorityName() {
	    return assigningAuthorityName;
	}
	
	/**
	 * Set a value to attribute assigningAuthorityName.
	 * @param assigningAuthorityName : 
	                     A human readable name or mnemonic for the assigning
	                     authority. This name may be provided solely for the
	                     convenience of unaided humans interpreting an  value
	                     and can have no computational meaning. Note: no
	                     automated processing must depend on the assigning
	                     authority name to be present in any form.
	 */
	public void setAssigningAuthorityName(String assigningAuthorityName) {
	    this.assigningAuthorityName = assigningAuthorityName;
	}
	
	
	
	
	/**
	 * Return displayable.
	 * @return displayable : 
	                     Specifies if the identifier is intended for human
	                     display and data entry (displayable = true) as
	                     opposed to pure machine interoperation (displayable
	                     = false).
	 */
	public Boolean getDisplayable() {
	    return displayable;
	}
	
	/**
	 * Set a value to attribute displayable.
	 * @param displayable : 
	                     Specifies if the identifier is intended for human
	                     display and data entry (displayable = true) as
	                     opposed to pure machine interoperation (displayable
	                     = false).
	 */
	public void setDisplayable(Boolean displayable) {
	    this.displayable = displayable;
	}
	
	
	/**
	 * Return displayable.
	 * @return displayable : 
	                     Specifies if the identifier is intended for human
	                     display and data entry (displayable = true) as
	                     opposed to pure machine interoperation (displayable
	                     = false).
	 * Generated for the use on jsf pages
	 */
	 @Deprecated
	public Boolean isDisplayable() {
	    return displayable;
	}
	
	/**
	 * Return extension.
	 * @return extension : 
	                     A character string as a unique identifier within the
	                     scope of the identifier root.
	 */
	public String getExtension() {
	    return extension;
	}
	
	/**
	 * Set a value to attribute extension.
	 * @param extension : 
	                     A character string as a unique identifier within the
	                     scope of the identifier root.
	 */
	public void setExtension(String extension) {
	    this.extension = extension;
	}
	
	
	
	
	/**
	 * Return root.
	 * @return root : 
	                     A unique identifier that guarantees the global uniqueness
	                     of the instance identifier. The root alone may be the
	                     entire instance identifier.
	 */
	public String getRoot() {
	    return root;
	}
	
	/**
	 * Set a value to attribute root.
	 * @param root : 
	                     A unique identifier that guarantees the global uniqueness
	                     of the instance identifier. The root alone may be the
	                     entire instance identifier.
	 */
	public void setRoot(String root) {
	    this.root = root;
	}
	
	
	
	
	
	public Node get_xmlNodePresentation() {
		if (_xmlNodePresentation == null){
				JAXBContext jc;
				DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
				dbf.setNamespaceAware(true);
				DocumentBuilder db = null;
				Document doc = null;
				try {
					db = dbf.newDocumentBuilder();
					doc = db.newDocument();
				} catch (ParserConfigurationException ignored) {}
				try {
					jc = JAXBContext.newInstance("net.ihe.gazelle.hl7v3.datatypes");
					Marshaller m = jc.createMarshaller();
					m.marshal(this, doc);
					_xmlNodePresentation = doc.getElementsByTagNameNS("urn:hl7-org:v3", "II").item(0);
				} catch (JAXBException e) {
					try{
						db = dbf.newDocumentBuilder();
						_xmlNodePresentation = db.newDocument();
					}
					catch(Exception ignored){}
				}
			}
			return _xmlNodePresentation;
	}
	
	public void set_xmlNodePresentation(Node _xmlNodePresentation) {
		this._xmlNodePresentation = _xmlNodePresentation;
	}
	
	
	

	
	/**
     * validate by a module of validation
     * 
     */
   public static void validateByModule(II iI, String _location, ConstraintValidatorModule cvm, List<net.ihe.gazelle.validation.Notification> diagnostic){
   		if (iI != null){
   			net.ihe.gazelle.hl7v3.datatypes.ANY.validateByModule(iI, _location, cvm, diagnostic);
    	}
    }

	@Override public boolean equals(Object o) {
		if (this == o)
			return true;
		if (!(o instanceof II ii))
			return false;

        if (!Objects.equals(assigningAuthorityName, ii.assigningAuthorityName))
			return false;
		if (!Objects.equals(displayable, ii.displayable))
			return false;
		if (!Objects.equals(extension, ii.extension))
			return false;
        return Objects.equals(root, ii.root);
    }

	@Override public int hashCode() {
		int result = assigningAuthorityName != null ? assigningAuthorityName.hashCode() : 0;
		result = 31 * result + (displayable != null ? displayable.hashCode() : 0);
		result = 31 * result + (extension != null ? extension.hashCode() : 0);
		result = 31 * result + (root != null ? root.hashCode() : 0);
		return result;
	}
}